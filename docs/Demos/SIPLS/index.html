<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>SIPLS · ChemometricsTools</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link href="../../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>ChemometricsTools</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../../">Home</a></li><li><span class="toctext">Demos</span><ul><li><a class="toctext" href="../Transforms/">Transforms</a></li><li><a class="toctext" href="../Pipelines/">Pipelines</a></li><li><a class="toctext" href="../ClassificationExample/">Classification</a></li><li><a class="toctext" href="../RegressionExample/">Regression</a></li><li class="current"><a class="toctext" href>SIPLS</a><ul class="internal"></ul></li><li><a class="toctext" href="../CalibXfer/">Calibration Transfer</a></li><li><a class="toctext" href="../CurveResolution/">Curve Resolution</a></li></ul></li><li><span class="toctext">API</span><ul><li><a class="toctext" href="../../man/Preprocess/">Preprocessing</a></li><li><a class="toctext" href="../../man/Transformations/">Transformations/Pipelines</a></li><li><a class="toctext" href="../../man/Sampling/">Sampling</a></li><li><a class="toctext" href="../../man/Training/">Training</a></li><li><a class="toctext" href="../../man/TimeSeries/">Time Series</a></li><li><a class="toctext" href="../../man/RegressionModels/">Regression Models</a></li><li><a class="toctext" href="../../man/regressMetrics/">Regression Metrics</a></li><li><a class="toctext" href="../../man/ClassificationModels/">Classification Models</a></li><li><a class="toctext" href="../../man/classMetrics/">Classification Metrics</a></li><li><a class="toctext" href="../../man/Trees/">Tree Methods</a></li><li><a class="toctext" href="../../man/Ensemble/">Ensemble Models</a></li><li><a class="toctext" href="../../man/Clustering/">Clustering</a></li><li><a class="toctext" href="../../man/MultiWay/">MultiWay</a></li><li><a class="toctext" href="../../man/AnomalyDetection/">Anomaly Detection</a></li><li><a class="toctext" href="../../man/CurveResolution/">Curve Resolution</a></li><li><a class="toctext" href="../../man/Stats/">Stats.</a></li><li><a class="toctext" href="../../man/Dists/">Distance Measures</a></li><li><a class="toctext" href="../../man/PSO/">PSO</a></li><li><a class="toctext" href="../../man/GeneticAlgorithms/">Genetic Algorithms</a></li></ul></li><li><a class="toctext" href="../../man/FullAPI/">Full API</a></li></ul></nav><article id="docs"><header><nav><ul><li>Demos</li><li><a href>SIPLS</a></li></ul><a class="edit-page" href="https://github.com/caseykneale/ChemometricsTools.jl/blob/master/docs/src/Demos/SIPLS.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>SIPLS</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Stacked-Interval-Partial-Least-Squares-1" href="#Stacked-Interval-Partial-Least-Squares-1">Stacked Interval Partial Least Squares</a></h1><p>Here&#39;s a post I kind of debated making... I once read a paper stating that SIPLS was &quot;too complicated&quot; to implement, and used that as an argument to favor other methods. SIPLS is actually pretty simple, highly effective, and it has statistical guarantees. What&#39;s complicated about SIPLS is providing it to end-users without shielding them from the internals, or leaving them with a pile of hard to read low level code. I decided, the way to go for &#39;advanced&#39; methods, is to just provide convenience functions. Make life easier for an end-user that knows what they are doing. Demo&#39;s are for helping ferry people along and showing at least one way to do things, but there&#39;s no golden ticket one-line generic code-base here. Providing it, would be a mistake to people who would actually rely on using this sort of method.</p><h3><a class="nav-anchor" id="Steps-to-SIPLS-1" href="#Steps-to-SIPLS-1">4-Steps to SIPLS</a></h3><ol><li>Break the spectra&#39;s columnspace into invervals (the size can be CV&#39;d but below I just picked one), then we CV PLS models inside each interval.</li><li>On a hold out set(or via pooling), we find the prediction error of our intervals</li><li>Those errors are then reciprocally weighted</li><li>Apply those weights to future predictions via multiplication and sum the result of each interval model.</li></ol><h3><a class="nav-anchor" id=".-Crossvalidate-the-interval-models-1" href="#.-Crossvalidate-the-interval-models-1">1. Crossvalidate the interval models</a></h3><pre><code class="language-julia">MaxLvs = 10
CVModels = []
CVErr = []
Intervals = MakeIntervals( size(calib1)[2], 30 );
for interval in Intervals
    IntervalError = repeat([0.0], MaxLvs);
    Models = []

    for Lv in MaxLvs:-1:1
        for ( i, ( Fold, HoldOut ) ) in enumerate(KFoldsValidation(10, calib1, caliby))
            if Lv == MaxLvs
                KFoldModel = PartialLeastSquares(Fold[1][:,interval], Fold[2]; Factors = Lv)
                push!( Models, KFoldModel )
            end

            Predictions = Models[i]( HoldOut[1][:, interval]; Factors = Lv)
            IntervalError[Lv] += SSE( Predictions, HoldOut[2])
        end
    end
    OptimalLv = argmin(IntervalError)
    push!(CVModels, PartialLeastSquares(calib1[:, interval], caliby; Factors = OptimalLv) )
    push!(CVErr,    IntervalError[OptimalLv] )
end</code></pre><p>For fun, we can view the weights of each intervals relative error on the CV&#39;d spectra with this lovely convenience function,</p><pre><code class="language-julia">IntervalOverlay(calib1, Intervals, CVErr)</code></pre><p><img src="https://raw.githubusercontent.com/caseykneale/ChemometricsTools/master/images/SISPLSDemo/Overlay.png" alt="CVERR"/></p><h3><a class="nav-anchor" id=".-Validate-1" href="#.-Validate-1">2. Validate</a></h3><pre><code class="language-julia">VErr = []
IntervalError = repeat([0.0], MaxLvs);
for (model, interval) in enumerate(Intervals)
    push!(VErr, SSE( CVModels[model](valid1[:,interval]), validy) )
end</code></pre><h3><a class="nav-anchor" id=".-Make-reciprocal-weights-1" href="#.-Make-reciprocal-weights-1">3. Make reciprocal weights</a></h3><pre><code class="language-julia">StackedWeights = stackedweights(VErr);</code></pre><p>We can recycle that same plot recipe to observe what this weighting function does for us. After calling the stacked weights function we can see how much each interval will contribute to our additve model. In essence, the weights make the intervals with lower error contribute more to the final stacked model, <img src="https://raw.githubusercontent.com/caseykneale/ChemometricsTools/master/images/SISPLSDemo/OverlayStacked.png" alt="OS"/></p><h3><a class="nav-anchor" id=".-Pool-predictions-on-test-set-and-weight-results-1" href="#.-Pool-predictions-on-test-set-and-weight-results-1">4. Pool predictions on test set and weight results</a></h3><pre><code class="language-julia">Results = zeros(size(tst1)[1]);
for (model, interval) in enumerate(Intervals)
    Results += CVModels[model](tst1[:,interval]) .* StackedWeights[model]
end

RMSE( Results, tsty)</code></pre><p><code>&gt; 4.09</code></p><p>The RMSE from the SIPLS model is ~0.6 units less then that which we can observe from the same dataset using base PLSR in my <a href="https://github.com/caseykneale/ChemometricsTools/wiki/Calibration-Transfer:-Direct-Standardization-Demo">Calibration Transfer Demo</a>. This is actually really fast to run too. Every line in this script (aside from importing CSV) runs in roughly ~1-2 seconds.</p><footer><hr/><a class="previous" href="../RegressionExample/"><span class="direction">Previous</span><span class="title">Regression</span></a><a class="next" href="../CalibXfer/"><span class="direction">Next</span><span class="title">Calibration Transfer</span></a></footer></article></body></html>
